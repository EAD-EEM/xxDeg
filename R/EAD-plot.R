##' Writes the heading over each pair of plots for \code{ead.plot}
##'
##' @param name the name of the model fitted, i.e. sfo, dfop, etc.
##' @param fit A curve fit generated by one of the fit.* functions in this package
##' @param tunit A string giving the units for time
##' @return Nothing. This fuction just draws to the current plot
text.plot <- function(name, fit, tunit="") {
  L1 <- 0.5   # text line y coordinates
  L2 <- 0.1
  tSc <- dev.size()[1]/10 # scale factor for when monitor is too small for 8x10
  mypar <- par(c("mar","xpd"))
  par(mar=c(0, 2.6, 0,0), xpd=TRUE)
  plot.new()
  if(!inherits(fit, c("lm","nls", "opiorefit","list"))) {  # the case that the fit failed
    text(0, L1, paste(name, "failed"), cex=1.8*tSc, adj=c(0,0.5))
  }
  else {
    text(0, L1, name, cex=1.8*tSc,adj=c(0,0.5))
    co <- ifelse(inherits(fit,c("lm","nls")),coef(fit),fit$par)
    co <- as.list(signif(co,3))
    if(name=="DFOP") {
      slo.t <- signif(-log(2)/coef(fit)['r1'],3)
      text(1,L2,substitute(s*l*o*w~~t[1/2]==x~~tunit,
              list(x=slo.t, tunit=tunit)),adj=c(1,0), cex=1.3*tSc)
    }
    text(1,L1, fit[['eq']], adj=c(1,0.5), cex=1.3*tSc)
    err <- substitute("Model error"==x*"%", list(x=signif(fit$chisq[1],2)))
    aic <- try(substitute("AIC"==x, list(x=signif(AIC(fit),3))))
    if(inherits(aic,"try-error")) aic <- NA
    dt50 <- substitute(DT[50]==x~~tunit,
        list(x=signif(fit$dtx['dt50'],3), tunit=tunit))
    dt90 <- substitute(DT[90]==x~~tunit,
        list(x=signif(fit$dtx['dt90'],3), tunit=tunit))
   ## Note the line below does not work because paste messes up the subscripts
   ## in dt50 and dt90 and overwrites other text
   ## text(0, L2, expression(paste(err, aic,dt50,dt90, sep=";  ")),adj=c(0,0), cex=1.3*tSc)
   text(0.00, L2, err, adj=c(0,0), cex=1.3*tSc)
   text(0.20, L2, aic, adj=c(0.2, 0), cex=1.3*tSc)
   text(0.34, L2, dt50, adj=c(0.33, 0), cex=1.3*tSc)
   text(0.6, L2, dt90, adj=c(0.67,0), cex=1.3*tSc)
  }
  par(mypar)
  par(xpd=FALSE)
}

##' draws a curve (on an untransformed y-axis) on the current model from zero
##' to maxtime.
##' @param fit a curve fit generated by \code{lm}, \code{glm} or \code{nls}
##' @param maxtime the maximum time to generate output. The minimum time is
##'   fixed at zero.
##' @param ... Additional parameters passed to \code{lines}
##' @return nothing. Result is to draw a line on the current plot.
draw.fitted.curve <- function(fit, maxtime, ...) {
  xvals <- seq(0,maxtime, length.out=101)
  if(inherits(fit, c("lm","nls","opiorefit"))) {
    pred <- predict(fit, data.frame(day=xvals))
    if(inherits(fit, "lm") & length(grep("log", as.character(fit$call))) >=1)
      pred <- exp(pred)
  }
  ## Else if no longer needed since the only list case because opiorefit
  ## else if(inherits(fit, "list")) { # fit is from the optim function
  ##    co <- fit$par
  ##    pred <- co[1]*(co[1]^(co[2]-1)*(co[2]-1)*co[3]*xvals +1)^(1/(1-co[2]))
  ## }
  else
    warning(paste("Unknown fit:",class(fit),"Could not draw fitted curve."))
  lines(xvals, pred, ...)
}

##' A function for fitting curves to data and writing results to a single page
##'   graphical summary.
##' @param DF a data frame with time in the first column and concentrations in
##'   the second. DF can also be set to clipboard.
##' @param pagehead a vector of strings to print at the top of the output page.
##'   These will be taken from any non-tabular lines in the clipboard if \code{DF}
##'   is set to clipboard, overwriting this parameter.
##' @param tofit the models to fit. allowed values are \code{sfo}, \code{logomsfo},
##'   \code{dfop}, \code{iore} and \code{fomc}.
##' @param usecurrentdev If true the function will write the output to
##' the current graphics device rather than closing the current and
##' creating a new device. Default is FALSE
##' @param horiz Format the out put as six plots only, ignoring the
##' text output in the standard format. Generally makes sense only
##' with a device formatted wider than standard, so it is best used
##' with usecurrentdev=TRUE. Default is FALSE
##' @return A list of the fitted models, which are standard R fit
##' types (e.g. lm, nls) with some added data.
##' @export
ead.plot <- function(DF="clipboard",pagehead=NULL, tofit=c("sfo","dfop","iore"),usecurrentdev = FALSE,horiz=FALSE) {
   fits <- degfit(DF, pagehead, tofit)
   fits[["Data"]] <- NULL # Already have DF, and older code uses it
  ## Set up the plotting device:
  if(!usecurrentdev & !is.null(dev.list()))
    dev.off()  #close active window if there is one and we're not using it
  window.height <- if(usecurrentdev) dev.size()[2] else 3.2*length(tofit)+0.4
  if(!usecurrentdev) x11(width=8, height=10)
  print(paste("cex =", par("cex")))
  titlelines <- if(!is.null(pagehead[1])) length(pagehead)+2 else 0
  par(mar=c(4,4,0.5,0.5),mgp=c(2.2,0.8,0), oma=c(0,0,titlelines,0), family="serif")
  nfit <- length(fits)
  if(horiz) {
     layoutmat <- matrix(1:(3*nfit), nr=3)
     layoutmat <- layoutmat[c(3,1,2),]
     layout(layoutmat,heights=rep(c(1,5,5),nfit))
  }
  else {
     layoutmat <- cbind(nfit*3+1, matrix(rep(c(3,3,1,2),nfit)+
              rep(seq(0,(nfit-1)*3,by=3),each=4),byrow=TRUE, nc=2))
     layout(layoutmat, widths=c(4,8,8), heights=rep(c(3,7),nfit))
  }
  ##  print(paste("cex =", par("cex")))
  if(length(grep("^[0-9.eE\\-]$",names(DF)))>0)
    warning("Be sure first line of data is the column headings")
  timeunits <- strsplit(names(DF)[1], "[ ,(\\[)\\]]+", perl=TRUE )[[1]][2]
  if(is.na(timeunits)) timeunits <- ""
  resid <- lapply(fits, function(x) if(inherits(x, c("lm","nls"))) residuals(x) else 0)
  ## Plot the data, fits and residuals
  yl <- max(abs(do.call(c,resid)), na.rm=TRUE)*c(-1,1)# resid. plot y-axis limit
  xline <- 0:max(DF[,1])
  for(mod in names(fits)) {
    if(inherits(fits[[mod]], c("lm","nls", "opiorefit", "list"))) {
      plot(DF,ylim=c(0,max(DF[,2])))
      draw.fitted.curve(fits[[mod]], max(xline))
      rug(fits[[mod]][['dtx']], col="red3", ticksize=0.05)
      if(identical(class(fits[[mod]]), "lm") &
               length(grep("log", as.character(fits[[mod]]$call))) >=1) {
         plot(DF[,1], residuals(fits[[mod]]),
              xlab=names(DF)[1], ylab="Residuals (log)")
         rug(fits[[mod]][['dtx']], col="red3", ticksize=0.05)
      }
      else { # calculate and plot residuals for non-lm models
         ## if(inherits(fits[[mod]],c("opiorefit","list"))) {
         ##    P <- fits[[mod]]$par
         ##    pred <- P[1]*(P[1]^(P[2]-1)*(P[2]-1)*P[3]*DF[,1] +1)^(1/(1-P[2]))
         ##    resid <- data.frame(Day=DF[,1], Residuals=DF[,2] - pred)
         ##    ## Store these because class "opiorefit" has no residuals function now it does)
         ##    #fits[[mod]][['residuals']] <- resid
         ## }
         ## else {
            resid <- data.frame(Day=DF[,1], Residuals=residuals(fits[[mod]]))
 ##        }
            plot(Residuals~Day, resid, ylim=yl)
            rug(fits[[mod]][['dtx']], col="red3", ticksize=0.05)
         ## fit and plot natural splines:
         sp <- resid.spline(resid, k=c(3))
         fits[[mod]][['spfits']] <- sp  # save the fits in the model object
         matlines(sp[[1]][,1], sp[[1]][,-1], col=c("blue2","green3"), lty=1)
      }
      abline(h=0)
   }
    else {
       plot(1,1, type="n", xaxt='n', yaxt='n', xlab="", ylab="")
       text(1,1, "Curve fit failed")
       plot(1,1, type="n", xaxt='n', yaxt='n', xlab="", ylab="")
       text(1,1, "Curve fit failed")
    }
    ## Plot the text above the plot pair
    if(!horiz) text.plot(toupper(mod), fits[[mod]], timeunits)
    else {
       mypar <- par(c("mar","xpd"))
       par(mar=c(0, 0, 0, 0), xpd=TRUE)

       plot.new()
       text(0.5, 0.5, mod, cex=2)
       par(mypar)
    }
 }
  if(!horiz){
     ## Plot data table in subplot 10
     oldmar <- par("mar")
     par( mar=c(0,0,0,0))
     plot.new()
     head <- lapply(names(DF), strwrap, width=6) #split headings to multiple lines
     n.head.lines <- max(sapply(head, length))
     win.fac <- 7.5/window.height # adjusts line spacing based on window size
     line1 <- (window.height-0.15)/window.height
     for(i in 1:n.head.lines)
         text(c(0.1, .6), line1-(i-1)*win.fac/50, sapply(head,'[',i), adj=c(0,0))
     DF2 <- DF # new data frame with rounded concentrations
     DF2[,2] <- round(DF2[,2],4)
     for(i in 1:nrow(DF)) {
        text(c(0.1,.6),line1-(i+n.head.lines-0.7)*win.fac/50, DF2[i,], adj=c(0,0))
     }
     if(!is.null(pagehead)) {
        title.lines <- length(pagehead):(length(pagehead)-length(pagehead)+1)
        title.lines[-1] <- title.lines[-1] - 0.5
        mtext(pagehead, outer=TRUE, line=title.lines, adj=0,
              cex=c(1.5, rep(1.1, length(pagehead)-1)), at=0.07)
     }
     par(mar=oldmar)
  }
  ## the variable pred below was the returned value of the function before it
  ## returned statistics
  ## pred <- lapply(fits, function(x) {
  ##       if(inherits(x, c("lm","nls", "opiorefit"))) {
  ##         p <- predict(x, DF)
  ##         if(inherits(x, "lm") & length(grep("log", as.character(x$call))) >= 1)
  ##           p <- exp(p)
  ##       }
  ##       else if(inherits(x, "list")) { # optim returns a list
  ##          co <- x$par
  ##          p <- co[1]*(co[1]^(co[2]-1)*(co[2]-1)*co[3]*DF[,1] +1)^(1/(1-co[2]))
  ##       }
  ##       else p <- NA
  ##       p
  ##     })
  ##cbind(DF, pred)
  fits
}
